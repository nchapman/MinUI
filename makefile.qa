# LessUI Quality Assurance
# Static analysis, testing, and code formatting
#
# This makefile provides quality assurance tools for the LessUI codebase:
#   - Unit tests (Docker-based, using Debian Buster + GCC 8.3.0)
#   - Static analysis (clang-tidy for C code, shellcheck for scripts)
#   - Code formatting (clang-format with project style)
#
# Quick start:
#   make test    - Run all unit tests (recommended)
#   make lint    - Run all linting checks
#   make format  - Auto-format code (modifies files)
#
# The main makefile forwards to this file for test/lint/format targets.
# Run 'make -f makefile.qa help' for complete target list.

.PHONY: help lint lint-code lint-full lint-shell analyze test test-native format format-check clean-qa docker-build docker-test docker-shell

help:
	@echo "LessUI Quality Assurance Tools"
	@echo ""
	@echo "Main targets (use these):"
	@echo "  make test          - Run unit tests (Docker, recommended)"
	@echo "  make lint          - Run ALL linting checks (clang-tidy, format-check, shellcheck)"
	@echo "  make format        - Format code with clang-format (MODIFIES FILES)"
	@echo ""
	@echo "Individual lint targets:"
	@echo "  make lint-code     - Run clang-tidy on workspace/all/"
	@echo "  make lint-full     - Run clang-tidy on entire workspace (verbose)"
	@echo "  make analyze       - Run Clang Static Analyzer (deep analysis)"
	@echo "  make format-check  - Check if code is formatted (no changes)"
	@echo "  make lint-shell    - Run shellcheck on shell scripts"
	@echo ""
	@echo "Docker targets:"
	@echo "  make docker-test   - Run tests in Debian Buster container"
	@echo "  make docker-build  - Build test Docker image"
	@echo "  make docker-shell  - Enter Docker container for debugging"
	@echo ""
	@echo "Other:"
	@echo "  make test-native   - Run tests natively (not recommended on macOS)"
	@echo "  make clean-qa      - Clean QA artifacts"
	@echo ""
	@echo "Installing tools:"
	@echo "  macOS:  brew install llvm shellcheck sdl2 sdl2_image sdl2_ttf"
	@echo "  Ubuntu: sudo apt-get install clang-tidy clang-format shellcheck libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev"

# clang-tidy configuration
# Checks for: bugs, performance issues, readability, security
# Configuration in .clang-tidy file
# workspace/all/ is the primary focus (platform-independent code)
# Use LLVM 18 to match CI (GitHub Actions uses Ubuntu LLVM 18.1.3)
CLANG_TIDY = $(shell /opt/homebrew/opt/llvm@18/bin/clang-tidy --version >/dev/null 2>&1 && echo /opt/homebrew/opt/llvm@18/bin/clang-tidy || which clang-tidy)
TIDY_FLAGS = --quiet

# Source files to analyze
# Note: clock.c is excluded because it uses GCC nested functions (non-standard)
# All other files are linted on all platforms
TIDY_SOURCES = workspace/all/minui/*.c \
               workspace/all/minarch/*.c \
               workspace/all/common/*.c \
               workspace/all/minput/*.c \
               workspace/all/say/*.c \
               workspace/all/syncsettings/*.c

# Auto-detect SDL2 include path (works on both macOS and Ubuntu)
SDL2_CFLAGS := $(shell sdl2-config --cflags 2>/dev/null)
SDL2_PREFIX := $(shell sdl2-config --prefix 2>/dev/null)

# Desktop platform configuration for linting (works on macOS and Linux)
# Need parent include dir for <SDL2/SDL.h> style includes on macOS
ifneq ($(SDL2_PREFIX),)
    TIDY_SDL_INCLUDES = -I$(SDL2_PREFIX)/include $(SDL2_CFLAGS)
else
    TIDY_SDL_INCLUDES = $(SDL2_CFLAGS)
endif

# Compiler flags for clang-tidy (needs to understand how to compile the code)
# Uses desktop platform which works for both macOS development and Linux CI
TIDY_COMPILE_FLAGS = -DPLATFORM=\"desktop\" \
                     -DSDCARD_PATH=\"../../desktop/FAKESD\" \
                     -DUSE_SDL2 \
                     -DBUILD_DATE=\"$(shell date +%Y%m%d)\" \
                     -DBUILD_HASH=\"tidy\" \
                     -I workspace/all/common \
                     -I workspace/desktop/platform \
                     -I workspace/all/minarch/libretro-common/include \
                     -iquote workspace/all/minarch/libretro-common/include \
                     -I tests/support \
                     $(TIDY_SDL_INCLUDES) \
                     -std=gnu99

# Check if clang-tidy is installed
check-clang-tidy:
	@which $(CLANG_TIDY) > /dev/null || (echo "Error: clang-tidy not installed. Run 'brew install llvm' or 'apt-get install clang-tidy'" && exit 1)

check-shellcheck:
	@which shellcheck > /dev/null || (echo "Error: shellcheck not installed. Run 'brew install shellcheck' or 'apt-get install shellcheck'" && exit 1)

# Run all linting checks (code, format, shell scripts)
lint: check-clang-tidy check-clang-format check-shellcheck
	@echo "=================================" && \
	echo "Running ALL linting checks..." && \
	echo "=================================" && \
	echo "" && \
	$(MAKE) -f makefile.qa lint-code && \
	echo "" && \
	$(MAKE) -f makefile.qa format-check && \
	echo "" && \
	$(MAKE) -f makefile.qa lint-shell && \
	echo "" && \
	echo "=================================" && \
	echo "✓ All linting checks passed" && \
	echo "================================="

# Run clang-tidy on common code (platform-independent, highest priority)
lint-code: check-clang-tidy
	@echo "Running clang-tidy on workspace/all/ (common code)..."
	@echo "Checking for: bugs, performance issues, readability, security vulnerabilities"
	@echo ""
	@for file in $(TIDY_SOURCES); do \
		if [ -f "$$file" ]; then \
			$(CLANG_TIDY) $(TIDY_FLAGS) "$$file" -- $(TIDY_COMPILE_FLAGS) || exit 1; \
		fi; \
	done
	@echo ""
	@echo "✓ Static analysis complete"

# Run clang-tidy on entire workspace (includes platform-specific code)
lint-full: check-clang-tidy
	@echo "Running clang-tidy on entire workspace..."
	@find workspace -name "*.c" -type f \
		-not -path "*/libretro-common/*" \
		-not -path "*/cores/*" \
		-not -path "*/toolchains/*" \
		-not -path "*/other/*" \
		-exec $(CLANG_TIDY) $(TIDY_FLAGS) {} -- $(TIDY_COMPILE_FLAGS) \;

# Clang Static Analyzer (deep dataflow analysis)
# Finds: NULL derefs, memory leaks, dead code, logic errors
# Note: Runs on host (not in Docker) - analyzes source, not binaries
# Works on macOS (Homebrew) and Linux (apt packages)

# Auto-detect scan-build location
SCAN_BUILD := $(shell which scan-build 2>/dev/null || which /opt/homebrew/opt/llvm/bin/scan-build 2>/dev/null)

# Auto-detect SDL2 include path (works on both macOS and Ubuntu)
SDL2_CFLAGS := $(shell sdl2-config --cflags 2>/dev/null)

ANALYZE_FLAGS = -DPLATFORM=\"macos\" -DSDCARD_PATH=\"../../macos/FAKESD\" -DENABLE_INFO_LOGS -DENABLE_DEBUG_LOGS \
                -I workspace/all/common -I workspace/macos/platform \
                $(SDL2_CFLAGS) -DUSE_SDL2 -std=gnu99

check-scan-build:
	@if [ -z "$(SCAN_BUILD)" ]; then \
		echo "Error: scan-build not found"; \
		echo "  macOS: brew install llvm"; \
		echo "  Ubuntu: sudo apt-get install clang-tools"; \
		exit 1; \
	fi

analyze: check-scan-build
	@echo "================================="
	@echo "Running Clang Static Analyzer..."
	@echo "================================="
	@echo ""
	@echo "Analyzing minarch.c..."
	@rm -rf /tmp/lessui-analysis
	@$(SCAN_BUILD) -o /tmp/lessui-analysis --status-bugs \
		gcc -c workspace/all/minarch/minarch.c $(ANALYZE_FLAGS) \
		-o /tmp/minarch.o 2>&1 | grep -v "note:" || true
	@echo ""
	@echo "Analyzing minui.c..."
	@$(SCAN_BUILD) -o /tmp/lessui-analysis --status-bugs \
		gcc -c workspace/all/minui/minui.c $(ANALYZE_FLAGS) \
		-o /tmp/minui.o 2>&1 | grep -v "note:" || true
	@echo ""
	@echo "Analyzing common/*.c..."
	@for file in workspace/all/common/*.c; do \
		$(SCAN_BUILD) -o /tmp/lessui-analysis --status-bugs \
			gcc -c $$file $(ANALYZE_FLAGS) \
			-o /tmp/common.o 2>&1 | grep -v "note:" || true; \
	done
	@echo ""
	@echo "================================="
	@if ls /tmp/lessui-analysis/*/index.html >/dev/null 2>&1; then \
		echo "⚠️  Issues found! View report:"; \
		echo "   open /tmp/lessui-analysis/*/index.html"; \
	else \
		echo "✓ No issues found"; \
	fi
	@echo "================================="

###########################################################
# Test Configuration
TEST_CFLAGS = -std=c99 -Wall -Wextra -Wno-unused-parameter
TEST_INCLUDES = -I tests/support -I tests/support/unity -I workspace/all/common
TEST_UNITY = tests/support/unity/unity.c

# All test executables (built from tests/unit/ and tests/integration/)
TEST_EXECUTABLES = tests/utils_test tests/pad_test tests/collections_test tests/gfx_text_test tests/audio_resampler_test tests/minarch_paths_test tests/minui_utils_test tests/m3u_parser_test tests/minui_file_utils_test tests/map_parser_test tests/collection_parser_test tests/recent_parser_test tests/recent_writer_test tests/directory_utils_test tests/binary_file_utils_test tests/integration_workflows_test

# Default test target: use Docker
test: docker-test

# Native test target (for Linux or if Docker unavailable)
test-native: $(TEST_EXECUTABLES)
	@echo "Running unit tests (native)..."
	@for test in $(TEST_EXECUTABLES); do \
		./$$test; \
		echo ""; \
	done
	@echo "✓ All tests passed"

# Build logging system tests
tests/log_test: tests/unit/all/common/test_log.c workspace/all/common/log.c $(TEST_UNITY)
	@echo "Building logging system tests..."
	@$(CC) $(TEST_INCLUDES) $(TEST_CFLAGS) -D_DEFAULT_SOURCE -o $@ $^ -lpthread

# Build comprehensive utils tests
tests/utils_test: tests/unit/all/common/test_utils.c workspace/all/common/utils.c workspace/all/common/log.c $(TEST_UNITY)
	@echo "Building comprehensive utils tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS)

# Build PAD (input) tests
tests/pad_test: tests/unit/all/common/test_api_pad.c workspace/all/common/pad.c $(TEST_UNITY)
	@echo "Building PAD input tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS)

# Build collections (Array/Hash) tests
tests/collections_test: tests/unit/all/common/test_collections.c workspace/all/common/collections.c workspace/all/common/utils.c workspace/all/common/log.c $(TEST_UNITY)
	@echo "Building collections tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -D_POSIX_C_SOURCE=200809L

# Build GFX text utility tests (uses fff for TTF mocking)
tests/gfx_text_test: tests/unit/all/common/test_gfx_text.c workspace/all/common/gfx_text.c workspace/all/common/utils.c workspace/all/common/log.c tests/support/sdl_fakes.c $(TEST_UNITY)
	@echo "Building GFX text utility tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) -I tests/support/fff $(TEST_CFLAGS) -DUNIT_TEST_BUILD

# Build audio resampler tests (pure algorithm, no mocking needed)
tests/audio_resampler_test: tests/unit/all/common/test_audio_resampler.c workspace/all/common/audio_resampler.c $(TEST_UNITY)
	@echo "Building audio resampler tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS)

# Build MinArch path generation tests (pure sprintf logic)
tests/minarch_paths_test: tests/unit/all/common/test_minarch_paths.c workspace/all/common/minarch_paths.c $(TEST_UNITY)
	@echo "Building MinArch path generation tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS)

# Build LessUI launcher utility tests (pure string logic)
tests/minui_utils_test: tests/unit/all/common/test_minui_utils.c workspace/all/common/minui_utils.c workspace/all/common/utils.c workspace/all/common/log.c $(TEST_UNITY)
	@echo "Building LessUI launcher utility tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS)

# Build M3U parser tests (uses file mocking with GCC --wrap, Docker-only)
tests/m3u_parser_test: tests/unit/all/common/test_m3u_parser.c workspace/all/common/m3u_parser.c workspace/all/common/utils.c workspace/all/common/log.c tests/support/fs_mocks.c $(TEST_UNITY)
	@echo "Building M3U parser tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -D_POSIX_C_SOURCE=200809L -Wl,--wrap=exists -Wl,--wrap=fopen -Wl,--wrap=fclose -Wl,--wrap=fgets

# Build LessUI file utility tests (uses file mocking with GCC --wrap, Docker-only)
tests/minui_file_utils_test: tests/unit/all/common/test_minui_file_utils.c workspace/all/common/minui_file_utils.c workspace/all/common/utils.c workspace/all/common/log.c tests/support/fs_mocks.c $(TEST_UNITY)
	@echo "Building LessUI file utility tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -Wl,--wrap=exists -Wl,--wrap=fopen -Wl,--wrap=fclose -Wl,--wrap=fgets

# Build map.txt parser tests (uses file mocking with GCC --wrap, Docker-only)
tests/map_parser_test: tests/unit/all/common/test_map_parser.c workspace/all/common/map_parser.c workspace/all/common/utils.c workspace/all/common/log.c tests/support/fs_mocks.c $(TEST_UNITY)
	@echo "Building map.txt parser tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -Wl,--wrap=exists -Wl,--wrap=fopen -Wl,--wrap=fclose -Wl,--wrap=fgets

# Build collection parser tests (uses file mocking with GCC --wrap, Docker-only)
tests/collection_parser_test: tests/unit/all/common/test_collection_parser.c workspace/all/common/collection_parser.c workspace/all/common/utils.c workspace/all/common/log.c tests/support/fs_mocks.c $(TEST_UNITY)
	@echo "Building collection parser tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -D_POSIX_C_SOURCE=200809L -Wl,--wrap=exists -Wl,--wrap=fopen -Wl,--wrap=fclose -Wl,--wrap=fgets

# Build recent.txt file tests (uses file mocking with GCC --wrap, Docker-only)
tests/recent_parser_test: tests/unit/all/common/test_recent_parser.c workspace/all/common/recent_file.c workspace/all/common/utils.c workspace/all/common/log.c tests/support/fs_mocks.c $(TEST_UNITY)
	@echo "Building recent.txt parser tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -D_POSIX_C_SOURCE=200809L -Wl,--wrap=exists -Wl,--wrap=fopen -Wl,--wrap=fclose -Wl,--wrap=fgets

# Build recent.txt writer tests (uses real temp files, no --wrap needed)
tests/recent_writer_test: tests/unit/all/common/test_recent_writer.c workspace/all/common/recent_file.c workspace/all/common/utils.c workspace/all/common/log.c $(TEST_UNITY)
	@echo "Building recent.txt writer tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -D_POSIX_C_SOURCE=200809L

# Build directory utility tests (uses real temp directories, no --wrap needed)
tests/directory_utils_test: tests/unit/all/common/test_directory_utils.c workspace/all/common/minui_file_utils.c workspace/all/common/utils.c workspace/all/common/log.c $(TEST_UNITY)
	@echo "Building directory utility tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -D_DEFAULT_SOURCE

# Build binary file I/O tests (uses real temp files, no --wrap needed)
tests/binary_file_utils_test: tests/unit/all/common/test_binary_file_utils.c workspace/all/common/binary_file_utils.c workspace/all/common/log.c $(TEST_UNITY)
	@echo "Building binary file I/O tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) $(TEST_CFLAGS) -D_DEFAULT_SOURCE

# Build integration tests (tests multiple components working together with real file I/O)
tests/integration_workflows_test: tests/integration/test_workflows.c \
	tests/integration/integration_support.c \
	workspace/all/common/m3u_parser.c \
	workspace/all/common/map_parser.c \
	workspace/all/common/collection_parser.c \
	workspace/all/common/recent_file.c \
	workspace/all/common/minui_file_utils.c \
	workspace/all/common/binary_file_utils.c \
	workspace/all/common/minarch_paths.c \
	workspace/all/common/utils.c \
	workspace/all/common/log.c \
	$(TEST_UNITY)
	@echo "Building integration tests..."
	@$(CC) -o $@ $^ $(TEST_INCLUDES) -I tests/integration $(TEST_CFLAGS) -D_POSIX_C_SOURCE=200809L -D_DEFAULT_SOURCE

clean-tests:
	rm -f tests/log_test $(TEST_EXECUTABLES) tests/*.o tests/**/*.o tests/integration/*.o

###########################################################
# Code Formatting
# Use LLVM 18 to match CI
CLANG_FORMAT = $(shell /opt/homebrew/opt/llvm@18/bin/clang-format --version >/dev/null 2>&1 && echo /opt/homebrew/opt/llvm@18/bin/clang-format || which clang-format)
FORMAT_PATHS = workspace/all/minui/*.c \
               workspace/all/minarch/*.c \
               workspace/all/common/*.c \
               workspace/all/common/*.h \
               workspace/all/clock/*.c \
               workspace/all/minput/*.c \
               workspace/all/say/*.c \
               workspace/all/syncsettings/*.c

check-clang-format:
	@which $(CLANG_FORMAT) > /dev/null || (echo "Error: clang-format not installed. Run 'brew install llvm' or 'apt-get install clang-format'" && exit 1)

# Format code in-place (MODIFIES FILES)
format: check-clang-format
	@echo "Formatting code with clang-format..."
	@$(CLANG_FORMAT) -i $(FORMAT_PATHS)
	@echo "✓ Code formatted"
	@echo ""
	@echo "NOTE: Files were modified. Review changes with 'git diff'"

# Check if code is formatted (no modifications)
format-check: check-clang-format
	@echo "Checking code formatting..."
	@$(CLANG_FORMAT) --dry-run -Werror $(FORMAT_PATHS) 2>&1 || \
		(echo "✗ Code is not formatted. Run 'make -f makefile.qa format' to fix." && exit 1)
	@echo "✓ Code is properly formatted"

###########################################################
# Shell Script Linting

# Find all shell scripts we maintain (exclude third-party code)
# Excludes:
#   - workspace/*/other/* (third-party SDL, DTC, etc.)
#   - workspace/macos/FAKESD/* (generated test data)
#   - cores, toolchains (third-party)
SHELL_SCRIPTS = $(shell find skeleton workspace -name "*.sh" -type f \
                 -not -path "*/cores/*" \
                 -not -path "*/toolchains/*" \
                 -not -path "*/other/*" \
                 -not -path "*/macos/FAKESD/*" \
                 -not -path "*/em_ui.sh" \
                 2>/dev/null)
ROOT_SCRIPTS = commits.sh

lint-shell: check-shellcheck
	@echo "Running shellcheck on shell scripts..."
	@echo "Checking $(shell echo $(SHELL_SCRIPTS) $(ROOT_SCRIPTS) | wc -w | tr -d ' ') scripts (forgiving rules)"
	@echo ""
	@ERROR_COUNT=0; \
	for script in $(ROOT_SCRIPTS) $(SHELL_SCRIPTS); do \
		if [ -f "$$script" ]; then \
			shellcheck -S warning "$$script" || ERROR_COUNT=$$((ERROR_COUNT + 1)); \
		fi; \
	done; \
	if [ $$ERROR_COUNT -gt 0 ]; then \
		echo ""; \
		echo "Found issues in $$ERROR_COUNT script(s)"; \
		echo "Note: Using forgiving rules (see .shellcheckrc)"; \
		exit 1; \
	else \
		echo "✓ All shell scripts passed"; \
	fi

###########################################################
# Reporting and Cleanup

clean-qa:
	@echo "Cleaning QA artifacts..."
	rm -f clang-tidy-report.txt

# Generate static analysis report file
report: check-clang-tidy
	@echo "Generating static analysis report..."
	@for file in $(TIDY_SOURCES); do \
		if [ -f "$$file" ]; then \
			$(CLANG_TIDY) "$$file" -- $(TIDY_COMPILE_FLAGS) 2>&1 || true; \
		fi; \
	done > clang-tidy-report.txt
	@echo "Report saved to clang-tidy-report.txt"
	@wc -l clang-tidy-report.txt

###########################################################
# Docker Testing (recommended for consistency)
DOCKER_IMAGE = minui-test
DOCKER_RUN = docker run --rm -v $(shell pwd):/minui -w /minui $(DOCKER_IMAGE)

docker-build:
	@echo "Building test Docker image (Debian Buster)..."
	docker build -t $(DOCKER_IMAGE) -f tests/Dockerfile .
	@echo "✓ Docker image ready"

docker-test: docker-build
	@echo "Running tests in Docker container (Debian Buster)..."
	@echo ""
	$(DOCKER_RUN) make -f makefile.qa clean-tests test-native

docker-lint: docker-build
	@echo "Running linting in Docker container..."
	$(DOCKER_RUN) make -f makefile.qa lint

docker-shell: docker-build
	@echo "Entering Docker container shell..."
	docker run --rm -it -v $(shell pwd):/minui -w /minui $(DOCKER_IMAGE) /bin/bash
